---
title: Polyfill：Part03
date: 2022-06-26 02:37:01
permalink: /polyfill/core/p3/
categories:
  - polyfill
tags:
  - 
---

## String.endsWith()

Pushes support back to at least IE6.

```js
/**
 * String.prototype.endsWith() polyfill
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill
 */
if (!String.prototype.endsWith) {
 String.prototype.endsWith = function(searchStr, Position) {
  // This works much better than >= because
  // it compensates for NaN:
  if (!(Position < this.length)) {
   Position = this.length;
  } else {
   Position |= 0; // round position
  }
  return this.substr(Position - searchStr.length, searchStr.length) === searchStr;
 };
}
```

## String.includes()

Pushes support back to at least IE6.

```js
/**
 * String.prototype.includes() polyfill
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes#Polyfill
 */
if (!String.prototype.includes) {
 String.prototype.includes = function(search, start) {
  'use strict';

  if (search instanceof RegExp) {
   throw TypeError('first argument must not be a RegExp');
  }
  if (start === undefined) { start = 0; }
  return this.indexOf(search, start) !== -1;
 };
}
```

## String.padEnd()

Pushes support back to at least IE6.

```js
/**
 * String.prototype.padStart() polyfill
 * https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd
 */
if (!String.prototype.padEnd) {
 String.prototype.padEnd = function padEnd(targetLength,padString) {
  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
  padString = String((typeof padString !== 'undefined' ? padString : ' '));
  if (this.length > targetLength) {
   return String(this);
  }
  else {
   targetLength = targetLength-this.length;
   if (targetLength > padString.length) {
    padString += padString.repeat(targetLength/padString.length); //append to original to ensure we are longer than needed
   }
   return String(this) + padString.slice(0,targetLength);
  }
 };
}
```

## String.padStart()

Pushes support back to at least IE6.

```js
/**
 * String.prototype.padStart() polyfill
 * https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
 */
if (!String.prototype.padStart) {
 String.prototype.padStart = function padStart(targetLength,padString) {
  targetLength = targetLength>>0; //truncate if number or convert non-number to 0;
  padString = String((typeof padString !== 'undefined' ? padString : ' '));
  if (this.length > targetLength) {
   return String(this);
  }
  else {
   targetLength = targetLength-this.length;
   if (targetLength > padString.length) {
    padString += padString.repeat(targetLength/padString.length); //append to original to ensure we are longer than needed
   }
   return padString.slice(0,targetLength) + String(this);
  }
 };
}
```

## String.repeat()

Pushes support back to IE9.

```js
/**
 * String.prototype.repeat() polyfill
 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat#Polyfill
 */
if (!String.prototype.repeat) {
 String.prototype.repeat = function(count) {
  'use strict';
  if (this == null)
   throw new TypeError('can\'t convert ' + this + ' to object');

  var str = '' + this;
  // To convert string to integer.
  count = +count;
  // Check NaN
  if (count != count)
   count = 0;

  if (count < 0)
   throw new RangeError('repeat count must be non-negative');

  if (count == Infinity)
   throw new RangeError('repeat count must be less than infinity');

  count = Math.floor(count);
  if (str.length == 0 || count == 0)
   return '';

  // Ensuring count is a 31-bit integer allows us to heavily optimize the
  // main part. But anyway, most current (August 2014) browsers can't handle
  // strings 1 << 28 chars or longer, so:
  if (str.length * count >= 1 << 28)
   throw new RangeError('repeat count must not overflow maximum string size');

  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
 }
}
```

## String.startsWith()

Pushes support back to at least IE6.

```js
/**
 * String.prototype.startsWith() polyfill
 */
if (!String.prototype.startsWith) {
 String.prototype.startsWith = function(search, pos){
  return this.slice(pos || 0, search.length) === search;
 };
}
```

## String.trim()

Pushes support back to at least IE6.

```js
/**
 * String.prototype.trim() polyfill
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
 */
if (!String.prototype.trim) {
 String.prototype.trim = function () {
  return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
 };
}
```

## String.trimEnd()

Pushes support back to IE9.

```js
/**
 * String.prototype.trimEnd() polyfill
 * Adapted from polyfill.io
 */
if (!String.prototype.trimEnd) {
 String.prototype.trimEnd = function () {
  return this.replace(new RegExp(/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/.source + '$', 'g'), '');
 };
}
```

## String.trimStart()

Pushes support back to IE9.

```js
/**
 * String.prototype.trimStart() polyfill
 * Adapted from polyfill.io
 */
if (!String.prototype.trimStart) {
 String.prototype.trimStart = function () {
  return this.replace(new RegExp('^' + /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/.source, 'g'), '');
 };
}
```

## URL

Pushes support back to IE9.

```js
/**
 * URL Polyfill
 * Draft specification: https://url.spec.whatwg.org
 * https://polyfill.io/
 */
(function (global) {
 'use strict';

 function isSequence(o) {
  if (!o) return false;
  if ('Symbol' in global && 'iterator' in global.Symbol &&
    typeof o[Symbol.iterator] === 'function') return true;
  if (Array.isArray(o)) return true;
  return false;
 }

 function toArray(iter) {
  return ('from' in Array) ? Array.from(iter) : Array.prototype.slice.call(iter);
 }

 (function() {

  // Browsers may have:
  // * No global URL object
  // * URL with static methods only - may have a dummy constructor
  // * URL with members except searchParams
  // * Full URL API support
  var origURL = global.URL;
  var nativeURL;
  try {
   if (origURL) {
    nativeURL = new global.URL('http://example.com');
    if ('searchParams' in nativeURL) {
     var url = new URL('http://example.com');
     url.search = 'a=1&b=2';
     if (url.href === 'http://example.com/?a=1&b=2') {
      url.search = '';
      if (url.href === 'http://example.com/') {
       return;
      }
     }
    }
    if (!('href' in nativeURL)) {
     nativeURL = undefined;
    }
    nativeURL = undefined;
   }
  // eslint-disable-next-line no-empty
  } catch (_) {}

  // NOTE: Doesn't do the encoding/decoding dance
  function urlencoded_serialize(pairs) {
   var output = '', first = true;
   pairs.forEach(function (pair) {
    var name = encodeURIComponent(pair.name);
    var value = encodeURIComponent(pair.value);
    if (!first) output += '&';
    output += name + '=' + value;
    first = false;
   });
   return output.replace(/%20/g, '+');
  }

  // NOTE: Doesn't do the encoding/decoding dance
  function urlencoded_parse(input, isindex) {
   var sequences = input.split('&');
   if (isindex && sequences[0].indexOf('=') === -1)
    sequences[0] = '=' + sequences[0];
   var pairs = [];
   sequences.forEach(function (bytes) {
    if (bytes.length === 0) return;
    var index = bytes.indexOf('=');
    if (index !== -1) {
     var name = bytes.substring(0, index);
     var value = bytes.substring(index + 1);
    } else {
     name = bytes;
     value = '';
    }
    name = name.replace(/\+/g, ' ');
    value = value.replace(/\+/g, ' ');
    pairs.push({ name: name, value: value });
   });
   var output = [];
   pairs.forEach(function (pair) {
    output.push({
     name: decodeURIComponent(pair.name),
     value: decodeURIComponent(pair.value)
    });
   });
   return output;
  }

  function URLUtils(url) {
   if (nativeURL)
    return new origURL(url);
   var anchor = document.createElement('a');
   anchor.href = url;
   return anchor;
  }

  function URLSearchParams(init) {
   var $this = this;
   this._list = [];

   if (init === undefined || init === null) {
    // no-op
   } else if (init instanceof URLSearchParams) {
    // In ES6 init would be a sequence, but special case for ES5.
    this._list = urlencoded_parse(String(init));
   } else if (typeof init === 'object' && isSequence(init)) {
    toArray(init).forEach(function(e) {
     if (!isSequence(e)) throw TypeError();
     var nv = toArray(e);
     if (nv.length !== 2) throw TypeError();
     $this._list.push({name: String(nv[0]), value: String(nv[1])});
    });
   } else if (typeof init === 'object' && init) {
    Object.keys(init).forEach(function(key) {
     $this._list.push({name: String(key), value: String(init[key])});
    });
   } else {
    init = String(init);
    if (init.substring(0, 1) === '?')
     init = init.substring(1);
    this._list = urlencoded_parse(init);
   }

   this._url_object = null;
   this._setList = function (list) { if (!updating) $this._list = list; };

   var updating = false;
   this._update_steps = function() {
    if (updating) return;
    updating = true;

    if (!$this._url_object) return;

    // Partial workaround for IE issue with 'about:'
    if ($this._url_object.protocol === 'about:' &&
      $this._url_object.pathname.indexOf('?') !== -1) {
     $this._url_object.pathname = $this._url_object.pathname.split('?')[0];
    }

    $this._url_object.search = urlencoded_serialize($this._list);

    updating = false;
   };
  }


  Object.defineProperties(URLSearchParams.prototype, {
   append: {
    value: function (name, value) {
     this._list.push({ name: name, value: value });
     this._update_steps();
    }, writable: true, enumerable: true, configurable: true
   },

   'delete': {
    value: function (name) {
     for (var i = 0; i < this._list.length;) {
      if (this._list[i].name === name)
       this._list.splice(i, 1);
      else
       ++i;
     }
     this._update_steps();
    }, writable: true, enumerable: true, configurable: true
   },

   get: {
    value: function (name) {
     for (var i = 0; i < this._list.length; ++i) {
      if (this._list[i].name === name)
       return this._list[i].value;
     }
     return null;
    }, writable: true, enumerable: true, configurable: true
   },

   getAll: {
    value: function (name) {
     var result = [];
     for (var i = 0; i < this._list.length; ++i) {
      if (this._list[i].name === name)
       result.push(this._list[i].value);
     }
     return result;
    }, writable: true, enumerable: true, configurable: true
   },

   has: {
    value: function (name) {
     for (var i = 0; i < this._list.length; ++i) {
      if (this._list[i].name === name)
       return true;
     }
     return false;
    }, writable: true, enumerable: true, configurable: true
   },

   set: {
    value: function (name, value) {
     var found = false;
     for (var i = 0; i < this._list.length;) {
      if (this._list[i].name === name) {
       if (!found) {
        this._list[i].value = value;
        found = true;
        ++i;
       } else {
        this._list.splice(i, 1);
       }
      } else {
       ++i;
      }
     }

     if (!found)
      this._list.push({ name: name, value: value });

     this._update_steps();
    }, writable: true, enumerable: true, configurable: true
   },

   entries: {
    value: function() { return new Iterator(this._list, 'key+value'); },
    writable: true, enumerable: true, configurable: true
   },

   keys: {
    value: function() { return new Iterator(this._list, 'key'); },
    writable: true, enumerable: true, configurable: true
   },

   values: {
    value: function() { return new Iterator(this._list, 'value'); },
    writable: true, enumerable: true, configurable: true
   },

   forEach: {
    value: function(callback) {
     var thisArg = (arguments.length > 1) ? arguments[1] : undefined;
     this._list.forEach(function(pair) {
      callback.call(thisArg, pair.value, pair.name);
     });

    }, writable: true, enumerable: true, configurable: true
   },

   toString: {
    value: function () {
     return urlencoded_serialize(this._list);
    }, writable: true, enumerable: false, configurable: true
   }
  });

  function Iterator(source, kind) {
   var index = 0;
   this.next = function() {
    if (index >= source.length)
     return {done: true, value: undefined};
    var pair = source[index++];
    return {done: false, value:
        kind === 'key' ? pair.name :
        kind === 'value' ? pair.value :
        [pair.name, pair.value]};
   };
  }

  if ('Symbol' in global && 'iterator' in global.Symbol) {
   Object.defineProperty(URLSearchParams.prototype, global.Symbol.iterator, {
    value: URLSearchParams.prototype.entries,
    writable: true, enumerable: true, configurable: true});
   Object.defineProperty(Iterator.prototype, global.Symbol.iterator, {
    value: function() { return this; },
    writable: true, enumerable: true, configurable: true});
  }

  function URL(url, base) {
   if (!(this instanceof global.URL))
    throw new TypeError("Failed to construct 'URL': Please use the 'new' operator.");

   if (base) {
    url = (function () {
     if (nativeURL) return new origURL(url, base).href;
     var iframe;
     try {
      var doc;
      // Use another document/base tag/anchor for relative URL resolution, if possible
      if (Object.prototype.toString.call(window.operamini) === "[object OperaMini]") {
       iframe = document.createElement('iframe');
       iframe.style.display = 'none';
       document.documentElement.appendChild(iframe);
       doc = iframe.contentWindow.document;
      } else if (document.implementation && document.implementation.createHTMLDocument) {
       doc = document.implementation.createHTMLDocument('');
      } else if (document.implementation && document.implementation.createDocument) {
       doc = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);
       doc.documentElement.appendChild(doc.createElement('head'));
       doc.documentElement.appendChild(doc.createElement('body'));
      } else if (window.ActiveXObject) {
       doc = new window.ActiveXObject('htmlfile');
       doc.write('<head></head><body></body>');
       doc.close();
      }

      if (!doc) throw Error('base not supported');

      var baseTag = doc.createElement('base');
      baseTag.href = base;
      doc.getElementsByTagName('head')[0].appendChild(baseTag);
      var anchor = doc.createElement('a');
      anchor.href = url;
      return anchor.href;
     } finally {
      if (iframe)
       iframe.parentNode.removeChild(iframe);
     }
    }());
   }

   // An inner object implementing URLUtils (either a native URL
   // object or an HTMLAnchorElement instance) is used to perform the
   // URL algorithms. With full ES5 getter/setter support, return a
   // regular object For IE8's limited getter/setter support, a
   // different HTMLAnchorElement is returned with properties
   // overridden

   var instance = URLUtils(url || '');

   // Detect for ES5 getter/setter support
   // (an Object.defineProperties polyfill that doesn't support getters/setters may throw)
   var ES5_GET_SET = (function() {
    if (!('defineProperties' in Object)) return false;
    try {
     var obj = {};
     Object.defineProperties(obj, { prop: { get: function () { return true; } } });
     return obj.prop;
    } catch (_) {
     return false;
    }
   }());

   var self = ES5_GET_SET ? this : document.createElement('a');



   var query_object = new URLSearchParams(
    instance.search ? instance.search.substring(1) : null);
   query_object._url_object = self;

   Object.defineProperties(self, {
    href: {
     get: function () { return instance.href; },
     set: function (v) { instance.href = v; tidy_instance(); update_steps(); },
     enumerable: true, configurable: true
    },
    origin: {
     get: function () {
      if ('origin' in instance) return instance.origin;
      return this.protocol + '//' + this.host;
     },
     enumerable: true, configurable: true
    },
    protocol: {
     get: function () { return instance.protocol; },
     set: function (v) { instance.protocol = v; },
     enumerable: true, configurable: true
    },
    username: {
     get: function () { return instance.username; },
     set: function (v) { instance.username = v; },
     enumerable: true, configurable: true
    },
    password: {
     get: function () { return instance.password; },
     set: function (v) { instance.password = v; },
     enumerable: true, configurable: true
    },
    host: {
     get: function () {
      // IE returns default port in |host|
      var re = {'http:': /:80$/, 'https:': /:443$/, 'ftp:': /:21$/}[instance.protocol];
      return re ? instance.host.replace(re, '') : instance.host;
     },
     set: function (v) { instance.host = v; },
     enumerable: true, configurable: true
    },
    hostname: {
     get: function () { return instance.hostname; },
     set: function (v) { instance.hostname = v; },
     enumerable: true, configurable: true
    },
    port: {
     get: function () { return instance.port; },
     set: function (v) { instance.port = v; },
     enumerable: true, configurable: true
    },
    pathname: {
     get: function () {
      // IE does not include leading '/' in |pathname|
      if (instance.pathname.charAt(0) !== '/') return '/' + instance.pathname;
      return instance.pathname;
     },
     set: function (v) { instance.pathname = v; },
     enumerable: true, configurable: true
    },
    search: {
     get: function () { return instance.search; },
     set: function (v) {
      if (instance.search === v) return;
      instance.search = v; tidy_instance(); update_steps();
     },
     enumerable: true, configurable: true
    },
    searchParams: {
     get: function () { return query_object; },
     enumerable: true, configurable: true
    },
    hash: {
     get: function () { return instance.hash; },
     set: function (v) { instance.hash = v; tidy_instance(); },
     enumerable: true, configurable: true
    },
    toString: {
     value: function() { return instance.toString(); },
     enumerable: false, configurable: true
    },
    valueOf: {
     value: function() { return instance.valueOf(); },
     enumerable: false, configurable: true
    }
   });

   function tidy_instance() {
    var href = instance.href.replace(/#$|\?$|\?(?=#)/g, '');
    if (instance.href !== href)
     instance.href = href;
   }

   function update_steps() {
    query_object._setList(instance.search ? urlencoded_parse(instance.search.substring(1)) : []);
    query_object._update_steps();
   }

   return self;
  }

  if (origURL) {
   for (var i in origURL) {
    if (Object.prototype.hasOwnProperty.call(origURL, i) && typeof origURL[i] === 'function')
     URL[i] = origURL[i];
   }
  }

  global.URL = URL;
  global.URLSearchParams = URLSearchParams;
 }());

 // Patch native URLSearchParams constructor to handle sequences/records
 // if necessary.
 (function() {
  if (new global.URLSearchParams([['a', 1]]).get('a') === '1' &&
    new global.URLSearchParams({a: 1}).get('a') === '1')
   return;
  var orig = global.URLSearchParams;
  global.URLSearchParams = function(init) {
   if (init && typeof init === 'object' && isSequence(init)) {
    var o = new orig();
    toArray(init).forEach(function(e) {
     if (!isSequence(e)) throw TypeError();
     var nv = toArray(e);
     if (nv.length !== 2) throw TypeError();
     o.append(nv[0], nv[1]);
    });
    return o;
   } else if (init && typeof init === 'object') {
    o = new orig();
    Object.keys(init).forEach(function(key) {
     o.set(key, init[key]);
    });
    return o;
   } else {
    return new orig(init);
   }
  };
 }());

}(self));
```

## document.exitFullscreen()

Pushes support back to IE11.

```js
/**
 * document.exitFullScreen() polyfill
 * @author Chris Ferdinandi
 * @license MIT
 */
if (!document.exitFullscreen) {
 document.exitFullscreen = document.mozExitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
}
```

## document.fullscreenElement

Pushes support back to IE11.

```js
/**
 * document.fullscreenElement polyfill
 * Adapted from https://shaka-player-demo.appspot.com/docs/api/lib_polyfill_fullscreen.js.html
 * @author Chris Ferdinandi
 * @license MIT
 */
if (!document.fullscreenElement) {

 Object.defineProperty(document, 'fullscreenElement', {
  get: function() {
   return document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement;
  }
 });

 Object.defineProperty(document, 'fullscreenEnabled', {
  get: function() {
   return document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled;
  }
 });
}
```

## fetch()

Pushes support back to IE10.

```js
/**
 * Fetch Polyfill
 * https://github.com/github/fetch
 * (c) GitHub, Inc., MIT License
 */
(function (global, factory) {
 typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
 typeof define === 'function' && define.amd ? define(['exports'], factory) :
 (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

 var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
   'FileReader' in self &&
   'Blob' in self &&
   (function() {
    try {
     new Blob();
     return true
    } catch (e) {
     return false
    }
   })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
 };

 function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
 }

 if (support.arrayBuffer) {
  var viewClasses = [
   '[object Int8Array]',
   '[object Uint8Array]',
   '[object Uint8ClampedArray]',
   '[object Int16Array]',
   '[object Uint16Array]',
   '[object Int32Array]',
   '[object Uint32Array]',
   '[object Float32Array]',
   '[object Float64Array]'
  ];

  var isArrayBufferView =
   ArrayBuffer.isView ||
   function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
   };
 }

 function normalizeName(name) {
  if (typeof name !== 'string') {
   name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
   throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
 }

 function normalizeValue(value) {
  if (typeof value !== 'string') {
   value = String(value);
  }
  return value
 }

 // Build a destructive iterator for the value list
 function iteratorFor(items) {
  var iterator = {
   next: function() {
    var value = items.shift();
    return {done: value === undefined, value: value}
   }
  };

  if (support.iterable) {
   iterator[Symbol.iterator] = function() {
    return iterator
   };
  }

  return iterator
 }

 function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
   headers.forEach(function(value, name) {
    this.append(name, value);
   }, this);
  } else if (Array.isArray(headers)) {
   headers.forEach(function(header) {
    this.append(header[0], header[1]);
   }, this);
  } else if (headers) {
   Object.getOwnPropertyNames(headers).forEach(function(name) {
    this.append(name, headers[name]);
   }, this);
  }
 }

 Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
 };

 Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)];
 };

 Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null
 };

 Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
 };

 Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
 };

 Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
   if (this.map.hasOwnProperty(name)) {
    callback.call(thisArg, this.map[name], name, this);
   }
  }
 };

 Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
   items.push(name);
  });
  return iteratorFor(items)
 };

 Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
   items.push(value);
  });
  return iteratorFor(items)
 };

 Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
   items.push([name, value]);
  });
  return iteratorFor(items)
 };

 if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
 }

 function consumed(body) {
  if (body.bodyUsed) {
   return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true;
 }

 function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
   reader.onload = function() {
    resolve(reader.result);
   };
   reader.onerror = function() {
    reject(reader.error);
   };
  })
 }

 function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise
 }

 function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise
 }

 function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
   chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('')
 }

 function bufferClone(buf) {
  if (buf.slice) {
   return buf.slice(0)
  } else {
   var view = new Uint8Array(buf.byteLength);
   view.set(new Uint8Array(buf));
   return view.buffer
  }
 }

 function Body() {
  this.bodyUsed = false;

  this._initBody = function(body) {
   this._bodyInit = body;
   if (!body) {
    this._bodyText = '';
   } else if (typeof body === 'string') {
    this._bodyText = body;
   } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
    this._bodyBlob = body;
   } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
    this._bodyFormData = body;
   } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
    this._bodyText = body.toString();
   } else if (support.arrayBuffer && support.blob && isDataView(body)) {
    this._bodyArrayBuffer = bufferClone(body.buffer);
    // IE 10-11 can't handle a DataView body.
    this._bodyInit = new Blob([this._bodyArrayBuffer]);
   } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
    this._bodyArrayBuffer = bufferClone(body);
   } else {
    this._bodyText = body = Object.prototype.toString.call(body);
   }

   if (!this.headers.get('content-type')) {
    if (typeof body === 'string') {
     this.headers.set('content-type', 'text/plain;charset=UTF-8');
    } else if (this._bodyBlob && this._bodyBlob.type) {
     this.headers.set('content-type', this._bodyBlob.type);
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
     this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
    }
   }
  };

  if (support.blob) {
   this.blob = function() {
    var rejected = consumed(this);
    if (rejected) {
     return rejected
    }

    if (this._bodyBlob) {
     return Promise.resolve(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
     return Promise.resolve(new Blob([this._bodyArrayBuffer]))
    } else if (this._bodyFormData) {
     throw new Error('could not read FormData body as blob')
    } else {
     return Promise.resolve(new Blob([this._bodyText]))
    }
   };

   this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
     return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
    } else {
     return this.blob().then(readBlobAsArrayBuffer)
    }
   };
  }

  this.text = function() {
   var rejected = consumed(this);
   if (rejected) {
    return rejected
   }

   if (this._bodyBlob) {
    return readBlobAsText(this._bodyBlob)
   } else if (this._bodyArrayBuffer) {
    return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
   } else if (this._bodyFormData) {
    throw new Error('could not read FormData body as text')
   } else {
    return Promise.resolve(this._bodyText)
   }
  };

  if (support.formData) {
   this.formData = function() {
    return this.text().then(decode)
   };
  }

  this.json = function() {
   return this.text().then(JSON.parse)
  };

  return this
 }

 // HTTP methods whose capitalization should be normalized
 var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

 function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method
 }

 function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
   if (input.bodyUsed) {
    throw new TypeError('Already read')
   }
   this.url = input.url;
   this.credentials = input.credentials;
   if (!options.headers) {
    this.headers = new Headers(input.headers);
   }
   this.method = input.method;
   this.mode = input.mode;
   this.signal = input.signal;
   if (!body && input._bodyInit != null) {
    body = input._bodyInit;
    input.bodyUsed = true;
   }
  } else {
   this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
   this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
   throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body);
 }

 Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
 };

 function decode(body) {
  var form = new FormData();
  body
   .trim()
   .split('&')
   .forEach(function(bytes) {
    if (bytes) {
     var split = bytes.split('=');
     var name = split.shift().replace(/\+/g, ' ');
     var value = split.join('=').replace(/\+/g, ' ');
     form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
   });
  return form
 }

 function parseHeaders(rawHeaders) {
  var headers = new Headers();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
   var parts = line.split(':');
   var key = parts.shift().trim();
   if (key) {
    var value = parts.join(':').trim();
    headers.append(key, value);
   }
  });
  return headers
 }

 Body.call(Request.prototype);

 function Response(bodyInit, options) {
  if (!options) {
   options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
 }

 Body.call(Response.prototype);

 Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
   status: this.status,
   statusText: this.statusText,
   headers: new Headers(this.headers),
   url: this.url
  })
 };

 Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''});
  response.type = 'error';
  return response
 };

 var redirectStatuses = [301, 302, 303, 307, 308];

 Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
   throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
 };

 exports.DOMException = self.DOMException;
 try {
  new exports.DOMException();
 } catch (err) {
  exports.DOMException = function(message, name) {
   this.message = message;
   this.name = name;
   var error = Error(message);
   this.stack = error.stack;
  };
  exports.DOMException.prototype = Object.create(Error.prototype);
  exports.DOMException.prototype.constructor = exports.DOMException;
 }

 function fetch(input, init) {
  return new Promise(function(resolve, reject) {
   var request = new Request(input, init);

   if (request.signal && request.signal.aborted) {
    return reject(new exports.DOMException('Aborted', 'AbortError'))
   }

   var xhr = new XMLHttpRequest();

   function abortXhr() {
    xhr.abort();
   }

   xhr.onload = function() {
    var options = {
     status: xhr.status,
     statusText: xhr.statusText,
     headers: parseHeaders(xhr.getAllResponseHeaders() || '')
    };
    options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
    var body = 'response' in xhr ? xhr.response : xhr.responseText;
    resolve(new Response(body, options));
   };

   xhr.onerror = function() {
    reject(new TypeError('Network request failed'));
   };

   xhr.ontimeout = function() {
    reject(new TypeError('Network request failed'));
   };

   xhr.onabort = function() {
    reject(new exports.DOMException('Aborted', 'AbortError'));
   };

   xhr.open(request.method, request.url, true);

   if (request.credentials === 'include') {
    xhr.withCredentials = true;
   } else if (request.credentials === 'omit') {
    xhr.withCredentials = false;
   }

   if ('responseType' in xhr && support.blob) {
    xhr.responseType = 'blob';
   }

   request.headers.forEach(function(value, name) {
    xhr.setRequestHeader(name, value);
   });

   if (request.signal) {
    request.signal.addEventListener('abort', abortXhr);

    xhr.onreadystatechange = function() {
     // DONE (success or failure)
     if (xhr.readyState === 4) {
      request.signal.removeEventListener('abort', abortXhr);
     }
    };
   }

   xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  })
 }

 fetch.polyfill = true;

 if (!self.fetch) {
  self.fetch = fetch;
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;
 }

 exports.Headers = Headers;
 exports.Request = Request;
 exports.Response = Response;
 exports.fetch = fetch;

 Object.defineProperty(exports, '__esModule', { value: true });

})));
```

## matchMedia()

Pushes support back to IE9.

```js
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license. https://github.com/paulirish/matchMedia.js/ */

window.matchMedia || (window.matchMedia = function() {
    'use strict';

    // For browsers that support matchMedium api such as IE 9 and webkit
    var styleMedia = (window.styleMedia || window.media);

    // For those that don't support matchMedium
    if (!styleMedia) {
        var style       = document.createElement('style'),
            script      = document.getElementsByTagName('script')[0],
            info        = null;

        style.type  = 'text/css';
        style.id    = 'matchmediajs-test';

        if (!script) {
          document.head.appendChild(style);
        } else {
          script.parentNode.insertBefore(style, script);
        }

        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

        styleMedia = {
            matchMedium: function(media) {
                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                if (style.styleSheet) {
                    style.styleSheet.cssText = text;
                } else {
                    style.textContent = text;
                }

                // Test if media query is true or false
                return info.width === '1px';
            }
        };
    }

    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || 'all'),
            media: media || 'all'
        };
    };
}());
```

## matchMedia().onchange

Pushes support back to IE9.

```js
/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. MIT license */
(function(){
    // Bail out for browsers that have addListener support
    if (window.matchMedia && window.matchMedia('all').addListener) {
        return false;
    }

    var localMatchMedia = window.matchMedia,
        hasMediaQueries = localMatchMedia('only all').matches,
        isListening     = false,
        timeoutID       = 0,    // setTimeout for debouncing 'handleChange'
        queries         = [],   // Contains each 'mql' and associated 'listeners' if 'addListener' is used
        handleChange    = function(evt) {
            // Debounce
            clearTimeout(timeoutID);

            timeoutID = setTimeout(function() {
                for (var i = 0, il = queries.length; i < il; i++) {
                    var mql         = queries[i].mql,
                        listeners   = queries[i].listeners || [],
                        matches     = localMatchMedia(mql.media).matches;

                    // Update mql.matches value and call listeners
                    // Fire listeners only if transitioning to or from matched state
                    if (matches !== mql.matches) {
                        mql.matches = matches;

                        for (var j = 0, jl = listeners.length; j < jl; j++) {
                            listeners[j].call(window, mql);
                        }
                    }
                }
            }, 30);
        };

    window.matchMedia = function(media) {
        var mql         = localMatchMedia(media),
            listeners   = [],
            index       = 0;

        mql.addListener = function(listener) {
            // Changes would not occur to css media type so return now (Affects IE <= 8)
            if (!hasMediaQueries) {
                return;
            }

            // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)
            // There should only ever be 1 resize listener running for performance
            if (!isListening) {
                isListening = true;
                window.addEventListener('resize', handleChange, true);
            }

            // Push object only if it has not been pushed already
            if (index === 0) {
                index = queries.push({
                    mql         : mql,
                    listeners   : listeners
                });
            }

            listeners.push(listener);
        };

        mql.removeListener = function(listener) {
            for (var i = 0, il = listeners.length; i < il; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                }
            }
        };

        return mql;
    };
}());
```

## window.customEvent()

Pushes support back to IE9.

```js
/**
 * CustomEvent() polyfill
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill
 */
(function () {

 if (typeof window.CustomEvent === "function") return false;

 function CustomEvent(event, params) {
  params = params || { bubbles: false, cancelable: false, detail: undefined };
  var evt = document.createEvent('CustomEvent');
  evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
  return evt;
 }

 CustomEvent.prototype = window.Event.prototype;

 window.CustomEvent = CustomEvent;
})();
```

## window.requestAnimationFrame()

Pushes support back to at least IE6.

```js
/**
 * requestAnimationFrame() polyfill
 * By Erik Möller. Fixes from Paul Irish and Tino Zijdel.
 * @link http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * @link http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * @license MIT
 */
(function() {
 var lastTime = 0;
 var vendors = ['ms', 'moz', 'webkit', 'o'];
 for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
  window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] ||
                                window[vendors[x]+'CancelRequestAnimationFrame'];
 }

 if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = function(callback, element) {
   var currTime = new Date().getTime();
   var timeToCall = Math.max(0, 16 - (currTime - lastTime));
   var id = window.setTimeout(function() { callback(currTime + timeToCall); },
    timeToCall);
   lastTime = currTime + timeToCall;
   return id;
  };
 }

 if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = function(id) {
   clearTimeout(id);
  };
 }
}());
```
